# Case Study & Technical Analysis

## Abstract
The **DBA SGA SQL Execution Plan History** report retrieves the actual execution plans for SQL statements currently residing in the library cache (SGA). Unlike the theoretical plan generated by `EXPLAIN PLAN`, this report shows the plan that the optimizer *actually* chose and compiled. It enriches this data by joining with segment statistics to display the size of the tables and indexes involved in the query, providing immediate context on the cost of full table scans.

## Technical Analysis

### Core Features
*   **Actual vs. Theoretical**: Displays the plan from `GV$SQL_PLAN`, which represents the compiled bytecode in memory.
*   **Object Sizing**: Integrates with `DBA_SEGMENTS` to show the physical size (in GB) of every object accessed in the plan. This is crucial for distinguishing between a harmless full scan on a lookup table vs. a disastrous full scan on a 500GB transaction table.
*   **Predicate Information**: Shows access and filter predicates, helping to diagnose why an index was or wasn't used.

### Key View
*   `GV$SQL_PLAN`: The row-source generation plan stored in the Shared Pool.

### Operational Use Cases
*   **Plan Flipping**: Diagnosing why a query suddenly changed performance by comparing its current plan hash value against historical knowledge.
*   **Index Validation**: Verifying if a newly created index is actually being picked up by the application code without needing to bounce the application.
*   **Cost Analysis**: Understanding the optimizer's estimated cardinality and cost for each step.
